<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 闭包]]></title>
    <url>%2F2018%2F07%2F02%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包 内部函数对外部函数作用域里对象的引用(非全局变量)，则称内部函数为闭包。 闭包就是内函数运用了外函数的变量(非全局变量)，并且外函数返回值是内函数的引用。这样内部函数就叫做闭包函数。 闭包简单示例： 12345678910111213#wai是外部函数def wai(): a = 1 #nei是内部函数 def nei(): #在内函数中 用到了外函数的临时变量 print(a) #外函数的返回值是内函数的引用 return neifunc = wai()#func == neifunc() 得出结果为： 继续理解闭包： 123456789101112def outer(x): def inner(y): return x +y return inner#x :10 func = outer(10)print('function:',func)#y :15#func(15)print('result:',func(15)) inner(y)就是内部函数，对在外部作用域(非全局作用域)的变量进行引用，x就是被引用的变量，x在外部作用域outer里面(非全局作用域)，则这个内部函数inner就是一个闭包。 结果为： 简单的乌龟赛跑： 12345678910111213141516171819202122232425def outer(): p = [0] def inner(): p[0] += 1 print("乌龟位置：",p[0]) return innert1 = outer()t2 = outer()t3 = outer()tDict = &#123; 't1':t1, 't2':t2, 't3':t3,&#125;while True: msg = input('你想让哪只乌龟跑？(t1,t2,t3)') if msg in tDict: #这里的tDict[msg]只是函数的引用，调用函数需要加括号()。 tDict[msg]() if msg == 'quit': print('GAME OVER') break 以下结果：分析结果： t1的值是在原来基础上不断做累加1的操作，说明在闭包函数inner存活期间，p变量会一直存活。 t1,t2,t3之间不会相互影响。(面型对象) 闭包无法直接访问外部函数的局部变量 123456789def outer(): x = 5 def inner(): x = x + 1 #直接使用了外部函数的局部变量 return x return innerfunc = outer()func() 直接使用会报错！ 在Python3中通过nonlocal(非局部的)关键字可以解决这个问题。 12345678910def outer(): x = 5 def inner(): nonlocal x #声明x为非全局变量 x = x + 1 return x return innerfunc = outer()func() 闭包无法修改外部函数的局部变量 12345678910def outer(): x = 5 def inner(): x = 1 #无法直接修改 print('内部的x:',x) print('外部的x:',x) inner() #这里直接调用内函数 print('外部的x:',x) outer() 外部函数的变量并没有被修改。 闭包思考： 闭包私有化了变量，实现了类似于面向对象中实例的功能。 在python中，使用闭包的另一个场景就是装饰器，也叫语法糖 @ 由于闭包引用了外部函数的局部变量，则外部函数中的局部变量没有及时释放，消耗内存]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 变量基础]]></title>
    <url>%2F2018%2F06%2F14%2Fpython%20%E5%8F%98%E9%87%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[变量 所谓变量就是给内存中的值取个名字方便引用。变量不仅可以是数字，还可以是任意数据类型。 变量赋值在Python中变量不需要声明大小类型，可以直接赋值使用。变量通过 = 赋值，可以把任意数据类型的值赋给变量。 同一变量可以反复赋值，哪怕更换类型。 123a = 123 #整型a = 'abc' #字符串型a = [1,2,3] #列表 在程序中可以随时修改变量的值，而Python只会记录最终修改的值。 同时可以给多个变量赋值。 123456a,b,c = 1,2,3#这样赋值的结果为：#a = 1#b = 2#c = 3 在使用变量前必须给变量赋值，变量赋值以后才会被创建。未给变量赋值而直接使用会报错。 1234a = 1bc = a + b# NameError: name 'b' is not defined Python中的变量有一个非常重要的性质：变量的赋值操作只是将变量名指向内存中的值，并不会实际复制值。它只是为数据对象取个相关的名字，名字是对象的引用而不是对象本身。你可以理解为变量是数据对象的代言人而不是其本身。 变量的命名和使用在Python中使用变量时，需要遵守一些规则。 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为message_1，但不能将其命名为1_message。 变量名不能包含空格，但可以使用下划线来分割其中的单词。例如，变量名greeting_message可行，但变量名greeting message会引发错误。 不要将Python关键字和函数名用作变量名，既不要使用Python用于特殊用途的单词，如print。 变量名应既简短又有描述性。例如，name比n好。student_name比s_n好，name_length 比 length_of_persons_name好。 慎用小写字母i 和大写字母O，因为它们可能被人看错成数字1和0. 变量名尽量使用小写字母。 Python关键字变量命名使用关键字会引发错误。 Python内置函数将内置函数作为变量名时，不会导致报错，但是会覆盖掉这些函数，使函数无法正常使用。]]></content>
      <categories>
        <category>python基础知识</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
